(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[277],{cl4H:function(e,n,t){"use strict";t.r(n);var r,a=t("q1tI"),i=t("o0o1"),s=t.n(i),d=t("HaE+"),o=(t("nX5y"),t("ThKj")),l=t("1OyB"),u=t("vuIU"),c=t("rePB"),m=(t("PMha"),t("5TJ6"),t("jWP/"),t("mbJ9")),f=t.n(m),p=t("mXS1"),h=t("LvDl"),I=t("EhJz"),g=t("dndX"),b=t("TjGc"),T=t("1PZI"),y=t("jZMG"),P=t("3+Em"),v=t("u/yc"),S=t("w3Pf"),w=t("MkVN"),A=t("HZtn"),C=t("uh5Q"),O=t("G6Tw");function D(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function N(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?D(Object(t),!0).forEach((function(n){Object(c.a)(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):D(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var k=function(){function e(){Object(l.a)(this,e),Object(c.a)(this,"_dummyTrades",void 0);var n=new o.a;this._dummyTrades=[];for(var t=1;t<=2e5;t++)this._dummyTrades.push(n.createTrade(t))}return Object(u.a)(e,[{key:"getRows",value:function(e){var n=this.getTradesRange(e.request.startRow,e.request.endRow-e.request.startRow,r.configApi.configGetAdaptableSearchState(),r.configApi.configGetAdaptableSortState()),t=B<=e.endRow?B:-1;e.successCallback(n,t)}},{key:"getTradesRange",value:function(){var e,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:100,a=arguments.length>2?arguments[2]:void 0,i=arguments.length>3?arguments[3]:void 0,s=this._dummyTrades;if(null!=a.columnFilters&&(null===(e=a.columnFilters)||void 0===e?void 0:e.length)>0&&a.columnFilters.forEach((function(e){var n,t=e.Predicate;null!=t.Inputs&&t.Inputs.length>0&&(n=t.Inputs[0]);var a=e.ColumnId;if("Blanks"==t.PredicateId)s=s.filter((function(e){return null==e[a]||void 0==e[a]||""==e[a]}));else if("NonBlanks"==t.PredicateId)s=s.filter((function(e){return null!=e[a]&&void 0!=e[a]&&""!=e[a]}));else if("Values"==t.PredicateId)s=s.filter((function(e){var n;return null!=e[a]&&void 0!=e[a]&&(null===(n=t.Inputs)||void 0===n?void 0:n.includes(e[a]))}));else switch(s=s.filter((function(e){return void 0!=e[a]})),r.columnApi.getColumnDataTypeFromColumnId(e.ColumnId)){case"Boolean":"True"==t.PredicateId?s=s.filter((function(e){return 1==e[a]})):"False"==t.PredicateId&&(s=s.filter((function(e){return 0==e[a]})));break;case"String":"Is"==t.PredicateId&&n?s=s.filter((function(e){return e[a]==n})):"IsNot"==t.PredicateId&&n?s=s.filter((function(e){return e[a]!==n})):"Contains"==t.PredicateId&&n?s=s.filter((function(e){return e[a].includes(n)})):"StartsWith"==t.PredicateId&&n?s=s.filter((function(e){return e[a].startsWith(n)})):"EndsWith"==t.PredicateId&&n?s=s.filter((function(e){return e[a].endsWith(n)})):"Regex"==t.PredicateId&&n&&(s=s.filter((function(e){return new RegExp(n).test(e[a])})));break;case"Number":if("Equals"==t.PredicateId&&n)s=s.filter((function(e){return e[a]==n}));else if("NotEquals"==t.PredicateId&&n)s=s.filter((function(e){return e[a]!==n}));else if("GreaterThan"==t.PredicateId&&n)s=s.filter((function(e){return Number(e[a])>Number(n)}));else if("LessThan"==t.PredicateId&&n)s=s.filter((function(e){return Number(e[a])<Number(n)}));else if("Positive"==t.PredicateId)s=s.filter((function(e){return Number(e[a])>0}));else if("Negative"==t.PredicateId)s=s.filter((function(e){return Number(e[a])<0}));else if("Between"==t.PredicateId&&n){var i=t.Inputs[1];i&&(s=s.filter((function(e){return Number(e[a])>n&&Number(e[a])<i})))}else if("NotBetween"==t.PredicateId&&n){var d=t.Inputs[1];d&&(s=s.filter((function(e){return Number(e[a])<n||Number(e[a])>d})))}break;case"Date":"On"==t.PredicateId&&n?s=s.filter((function(e){return e[a]==n})):"NotOn"==t.PredicateId&&n?s=s.filter((function(e){return e[a]!==n})):"After"==t.PredicateId&&n?s=s.filter((function(e){return Object(I.default)(e[a],n)})):"Before"==t.PredicateId&&n?s=s.filter((function(e){return Object(g.default)(e[a],n)})):"Today"==t.PredicateId?s=s.filter((function(e){return Object(b.default)(e[a])})):"Yesterday"==t.PredicateId?s=s.filter((function(e){return Object(T.default)(e[a])})):"Tomorrow"==t.PredicateId?s=s.filter((function(e){return Object(y.default)(e[a])})):"ThisWeek"==t.PredicateId?s=s.filter((function(e){return Object(P.default)(e[a])})):"ThisMonth"==t.PredicateId?s=s.filter((function(e){return Object(v.default)(e[a])})):"ThisQuarter"==t.PredicateId?s=s.filter((function(e){return Object(S.default)(e[a])})):"ThisYear"==t.PredicateId?s=s.filter((function(e){return Object(w.default)(e[a])})):"InPast"==t.PredicateId?s=s.filter((function(e){return Object(A.default)(e[a])})):"InFuture"==t.PredicateId?s=s.filter((function(e){return Object(C.default)(e[a])})):"NextWorkDay"==t.PredicateId?s=s.filter((function(e){return Object(O.default)(e[a],r.calendarApi.getNextWorkingDay())})):"NextWorkDay"==t.PredicateId&&(s=s.filter((function(e){return Object(O.default)(e[a],r.calendarApi.getPreviousWorkingDay())})))}})),i.columnSorts.length>0){var d=[],o=[];i.columnSorts.forEach((function(e){d.push(e.ColumnId),o.push(e.SortOrder.toLowerCase())})),s=Object(h.orderBy)(s,d,o)}return s.slice(n,n+t)}},{key:"getUniqueColumnValues",value:function(e){var n=Object(h.uniqBy)(this._dummyTrades,e.ColumnId).map((function(n){return n[e.ColumnId]})).filter((function(e){return void 0!=e}));return"Date"==e.DataType?n.map((function(e){return e.toDateString()})):n}}]),e}(),j=function(){var e=Object(d.a)(s.a.mark((function e(n){var t;return s.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return t={primaryKey:"TradeId",userName:"Demo User",adaptableId:"Server Mode Demo",predefinedConfig:{Dashboard:{Tabs:[{Name:"Server Demo Toolbar",Toolbars:["Export","Layout","SystemStatus","Filter"]}]},UserInterface:{PermittedValuesItems:[{Scope:{All:!0},GetColumnValuesFunction:"GetUniqueColumnValues"}]}},vendorGrid:N(N({},{columnDefs:n,enableRangeSelection:!0,sideBar:!0,suppressMenuHide:!0,columnTypes:{abColDefNumber:{},abColDefString:{},abColDefBoolean:{},abColDefDate:{},abColDefObject:{},abColDefNumberArray:{}}}),{},{rowModelType:"serverSide",modules:p.a}),userFunctions:[{name:"GetUniqueColumnValues",type:"GetColumnValuesFunction",handler:function(e){return G.getUniqueColumnValues(e)}}]},e.next=4,f.a.init(t);case 4:return(r=e.sent).eventApi.on("AdaptableReady",(function(e){e.vendorGrid.api.setServerSideDatasource(G)})),e.abrupt("return",{adaptableOptions:t,adaptableApi:r});case 7:case"end":return e.stop()}}),e)})));return function(n){return e.apply(this,arguments)}}(),B=100,G=new k,F=Object(d.a)(s.a.mark((function e(){var n,t,r,a;return s.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return(n=new o.a).setUpAgGridLicence(),console.log(508420),t=n.getBasicTradeSchema(),e.next=6,j(t);case 6:return r=e.sent,a=r.adaptableOptions,r.adaptableApi,a.vendorGrid.onGridReady=function(e){e.columnApi.autoSizeAllColumns(),setTimeout((function(){return e.columnApi.autoSizeAllColumns()}),1),e.api.addEventListener("newColumnsLoaded",(function(){e.columnApi.autoSizeAllColumns()})),e.api.closeToolPanel()},e.abrupt("return",{code:"import '@adaptabletools/adaptable/index.css';\nimport '@ag-grid-community/all-modules/dist/styles/ag-grid.css';\nimport '@ag-grid-community/all-modules/dist/styles/ag-theme-balham.css';\nimport Adaptable from '@adaptabletools/adaptable/agGrid';\nimport { GridOptions, ColDef } from '@ag-grid-community/all-modules';\nimport {\n  AdaptableOptions,\n  AdaptableApi,\n  AdaptableReadyInfo,\n  AdaptableSearchState,\n  ColumnFilter,\n  AdaptableColumn,\n  AdaptableSortState,\n  ColumnSort,\n} from '@adaptabletools/adaptable/types';\nimport { AllEnterpriseModules } from '@ag-grid-enterprise/all-modules';\nimport { ITrade } from '../../../Helpers/Trade';\nimport { HelperAgGrid } from '../../../Helpers/HelperAgGrid';\nimport { orderBy, uniqBy } from 'lodash';\nimport {\n  isAfter,\n  isBefore,\n  isFuture,\n  isPast,\n  isSameDay,\n  isThisMonth,\n  isThisQuarter,\n  isThisWeek,\n  isThisYear,\n  isToday,\n  isTomorrow,\n  isYesterday,\n} from 'date-fns';\nvar adaptableApi: AdaptableApi;\n\nclass MockServer {\n  _dummyTrades: ITrade[];\n\n  constructor() {\n    // create an inital dataset with 150,000 rows (to mimic many rows on the server)\n    const helperAgGrid = new HelperAgGrid();\n    this._dummyTrades = [];\n    for (let i = 1; i <= 200000; i++) {\n      this._dummyTrades.push(helperAgGrid.createTrade(i));\n    }\n  }\n\n  // called by ag-Grid whenever we need to get the next batch of rows\n  // we receieve the params object to get the start and end row numbers\n  // but we pass in the Adaptable Search State to perform filtering based on that\n  getRows(params: any) {\n    let rows = this.getTradesRange(\n      params.request.startRow,\n      params.request.endRow - params.request.startRow,\n      adaptableApi.configApi.configGetAdaptableSearchState(), // this is the current Adaptable Search State\n      adaptableApi.configApi.configGetAdaptableSortState() // this is the current Adaptable Sort State\n    );\n    const lastRow = BATCH_COUNT <= params.endRow ? BATCH_COUNT : -1;\n    params.successCallback(rows, lastRow);\n  }\n\n  // In the real world this will be done on the server likely using SQL or similar structures\n  // But here we do it in JavaScript to show how you can access the Column Filters in AdaptableSearchState\n  // Each Column Filter has a Predicate that we interrogate seperately\n  // We use a 3rd party date library 'date-fns' to manage dates but this can be done in any way that suits your requirements\n  getTradesRange(\n    start: number = 1,\n    count: number = 100,\n    searchState: AdaptableSearchState,\n    sortState: AdaptableSortState\n  ): ITrade[] {\n    let matchingTrades: ITrade[] = this._dummyTrades;\n    if (\n      searchState.columnFilters != null &&\n      searchState.columnFilters?.length > 0\n    ) {\n      searchState.columnFilters.forEach((columnFilter: ColumnFilter) => {\n        let predicate = columnFilter.Predicate;\n        let firstInput: any;\n        if (predicate.Inputs != null && predicate.Inputs.length > 0) {\n          firstInput = predicate.Inputs[0];\n        }\n        let columnId: string = columnFilter.ColumnId;\n\n        // Blanks, Non-Blanks and Values (a.k.a. IN) work across all DataTypes\n        if (predicate.PredicateId == 'Blanks') {\n          matchingTrades = matchingTrades.filter(\n            (t: any) =>\n              t[columnId] == null ||\n              t[columnId] == undefined ||\n              t[columnId] == ''\n          );\n        } else if (predicate.PredicateId == 'NonBlanks') {\n          matchingTrades = matchingTrades.filter(\n            (t: any) =>\n              t[columnId] != null &&\n              t[columnId] != undefined &&\n              t[columnId] != ''\n          );\n        } else if (predicate.PredicateId == 'Values') {\n          matchingTrades = matchingTrades.filter(\n            (t: any) =>\n              t[columnId] != null &&\n              t[columnId] != undefined &&\n              predicate.Inputs?.includes(t[columnId])\n          );\n        } else {\n          // work out the predicate based on the column's datatype using an an AdaptableApi.ColumnApi method\n          matchingTrades = matchingTrades.filter(\n            (t: any) => t[columnId] != undefined\n          );\n          switch (\n            adaptableApi.columnApi.getColumnDataTypeFromColumnId(\n              columnFilter.ColumnId\n            )\n          ) {\n            case 'Boolean':\n              if (predicate.PredicateId == 'True') {\n                matchingTrades = matchingTrades.filter(\n                  (t: any) => t[columnId] == true\n                );\n              } else if (predicate.PredicateId == 'False') {\n                matchingTrades = matchingTrades.filter(\n                  (t: any) => t[columnId] == false\n                );\n              }\n              break;\n\n            case 'String':\n              if (predicate.PredicateId == 'Is' && firstInput) {\n                matchingTrades = matchingTrades.filter(\n                  (t: any) => t[columnId] == firstInput\n                );\n              } else if (predicate.PredicateId == 'IsNot' && firstInput) {\n                matchingTrades = matchingTrades.filter(\n                  (t: any) => t[columnId] !== firstInput\n                );\n              } else if (predicate.PredicateId == 'Contains' && firstInput) {\n                matchingTrades = matchingTrades.filter((t: any) =>\n                  t[columnId].includes(firstInput)\n                );\n              } else if (predicate.PredicateId == 'StartsWith' && firstInput) {\n                matchingTrades = matchingTrades.filter((t: any) =>\n                  t[columnId].startsWith(firstInput)\n                );\n              } else if (predicate.PredicateId == 'EndsWith' && firstInput) {\n                matchingTrades = matchingTrades.filter((t: any) =>\n                  t[columnId].endsWith(firstInput)\n                );\n              } else if (predicate.PredicateId == 'Regex' && firstInput) {\n                matchingTrades = matchingTrades.filter((t: any) =>\n                  new RegExp(firstInput).test(t[columnId])\n                );\n              }\n              break;\n\n            case 'Number':\n              if (predicate.PredicateId == 'Equals' && firstInput) {\n                matchingTrades = matchingTrades.filter(\n                  (t: any) => t[columnId] == firstInput\n                );\n              } else if (predicate.PredicateId == 'NotEquals' && firstInput) {\n                matchingTrades = matchingTrades.filter(\n                  (t: any) => t[columnId] !== firstInput\n                );\n              } else if (predicate.PredicateId == 'GreaterThan' && firstInput) {\n                matchingTrades = matchingTrades.filter(\n                  (t: any) => Number(t[columnId]) > Number(firstInput)\n                );\n              } else if (predicate.PredicateId == 'LessThan' && firstInput) {\n                matchingTrades = matchingTrades.filter(\n                  (t: any) => Number(t[columnId]) < Number(firstInput)\n                );\n              } else if (predicate.PredicateId == 'Positive') {\n                matchingTrades = matchingTrades.filter(\n                  (t: any) => Number(t[columnId]) > 0\n                );\n              } else if (predicate.PredicateId == 'Negative') {\n                matchingTrades = matchingTrades.filter(\n                  (t: any) => Number(t[columnId]) < 0\n                );\n              } else if (predicate.PredicateId == 'Between' && firstInput) {\n                let secondInput: any = predicate!.Inputs![1];\n                if (secondInput) {\n                  matchingTrades = matchingTrades.filter(\n                    (t: any) =>\n                      Number(t[columnId]) > firstInput &&\n                      Number(t[columnId]) < secondInput\n                  );\n                }\n              } else if (predicate.PredicateId == 'NotBetween' && firstInput) {\n                let secondInput: any = predicate!.Inputs![1];\n                if (secondInput) {\n                  matchingTrades = matchingTrades.filter(\n                    (t: any) =>\n                      Number(t[columnId]) < firstInput ||\n                      Number(t[columnId]) > secondInput\n                  );\n                }\n              }\n              break;\n\n            case 'Date':\n              if (predicate.PredicateId == 'On' && firstInput) {\n                matchingTrades = matchingTrades.filter(\n                  (t: any) => t[columnId] == firstInput\n                );\n              } else if (predicate.PredicateId == 'NotOn' && firstInput) {\n                matchingTrades = matchingTrades.filter(\n                  (t: any) => t[columnId] !== firstInput\n                );\n              } else if (predicate.PredicateId == 'After' && firstInput) {\n                matchingTrades = matchingTrades.filter((t: any) =>\n                  isAfter(t[columnId], firstInput)\n                );\n              } else if (predicate.PredicateId == 'Before' && firstInput) {\n                matchingTrades = matchingTrades.filter((t: any) =>\n                  isBefore(t[columnId], firstInput)\n                );\n              } else if (predicate.PredicateId == 'Today') {\n                matchingTrades = matchingTrades.filter((t: any) =>\n                  isToday(t[columnId])\n                );\n              } else if (predicate.PredicateId == 'Yesterday') {\n                matchingTrades = matchingTrades.filter((t: any) =>\n                  isYesterday(t[columnId])\n                );\n              } else if (predicate.PredicateId == 'Tomorrow') {\n                matchingTrades = matchingTrades.filter((t: any) =>\n                  isTomorrow(t[columnId])\n                );\n              } else if (predicate.PredicateId == 'ThisWeek') {\n                matchingTrades = matchingTrades.filter((t: any) =>\n                  isThisWeek(t[columnId])\n                );\n              } else if (predicate.PredicateId == 'ThisMonth') {\n                matchingTrades = matchingTrades.filter((t: any) =>\n                  isThisMonth(t[columnId])\n                );\n              } else if (predicate.PredicateId == 'ThisQuarter') {\n                matchingTrades = matchingTrades.filter((t: any) =>\n                  isThisQuarter(t[columnId])\n                );\n              } else if (predicate.PredicateId == 'ThisYear') {\n                matchingTrades = matchingTrades.filter((t: any) =>\n                  isThisYear(t[columnId])\n                );\n              } else if (predicate.PredicateId == 'InPast') {\n                matchingTrades = matchingTrades.filter((t: any) =>\n                  isPast(t[columnId])\n                );\n              } else if (predicate.PredicateId == 'InFuture') {\n                matchingTrades = matchingTrades.filter((t: any) =>\n                  isFuture(t[columnId])\n                );\n              } else if (predicate.PredicateId == 'NextWorkDay') {\n                matchingTrades = matchingTrades.filter((t: any) =>\n                  isSameDay(\n                    t[columnId],\n                    adaptableApi.calendarApi.getNextWorkingDay()\n                  )\n                );\n              } else if (predicate.PredicateId == 'NextWorkDay') {\n                matchingTrades = matchingTrades.filter((t: any) =>\n                  isSameDay(\n                    t[columnId],\n                    adaptableApi.calendarApi.getPreviousWorkingDay()\n                  )\n                );\n              }\n              break;\n          }\n        }\n      });\n    }\n\n    // Finally lets apply any Sorting as required to match what is currently sorted in the Grid.\n    // The AdaptableSortState param gives us current sort info and the Lodash orderBy function replicates that for our data set.\n    if (sortState.columnSorts.length > 0) {\n      let sortedColumns: string[] = [];\n      let sortDirections: string[] = [];\n      sortState.columnSorts.forEach((cs: ColumnSort) => {\n        sortedColumns.push(cs.ColumnId);\n        sortDirections.push(cs.SortOrder.toLowerCase());\n      });\n      matchingTrades = orderBy(\n        matchingTrades,\n        sortedColumns,\n        sortDirections as any\n      );\n    }\n\n    return matchingTrades.slice(start, start + count);\n  }\n\n  // Retrieves all the distinct values - using 'uniqBy' from lodash\n  // In the real world this will run on the server\n  // However it demonstrates how you can pass AdapTable the values it needs to show in filter dropdowns when running in server mode\n  // This is invoked in UserFunctions section of AdaptableOptions\n  getUniqueColumnValues(column: AdaptableColumn): any[] {\n    let returnVals = uniqBy(this._dummyTrades, column.ColumnId)\n      .map((t: any) => {\n        return t[column.ColumnId];\n      })\n      .filter((v: any) => v != undefined);\n    if (column.DataType == 'Date') {\n      let formatDateValues = returnVals.map((v: Date) => {\n        return v.toDateString();\n      });\n      return formatDateValues;\n    } else {\n      return returnVals;\n    }\n  }\n}\nexport default async (columnDefs: ColDef[]) => {\n  const gridOptions: GridOptions = {\n    columnDefs,\n    enableRangeSelection: true,\n    sideBar: true,\n    suppressMenuHide: true,\n    columnTypes: {\n      abColDefNumber: {},\n      abColDefString: {},\n      abColDefBoolean: {},\n      abColDefDate: {},\n      abColDefObject: {},\n      abColDefNumberArray: {},\n    },\n  };\n\n  const adaptableOptions: AdaptableOptions = {\n    primaryKey: 'TradeId',\n    userName: 'Demo User',\n    adaptableId: 'Server Mode Demo',\n    predefinedConfig: {\n      Dashboard: {\n        Tabs: [\n          {\n            Name: 'Server Demo Toolbar',\n            Toolbars: ['Export', 'Layout', 'SystemStatus', 'Filter'],\n          },\n        ],\n      },\n      UserInterface: {\n        PermittedValuesItems: [\n          {\n            Scope: {\n              All: true,\n            },\n            GetColumnValuesFunction: 'GetUniqueColumnValues',\n          },\n        ],\n      },\n    },\n    vendorGrid: {\n      ...gridOptions,\n      rowModelType: 'serverSide',\n      modules: AllEnterpriseModules,\n    },\n    // provide an implmentation for the 'GetColumnValuesFunction' to get unique values\n    // this is paired with PermittedValues in PredefinedConfig\n    userFunctions: [\n      {\n        name: 'GetUniqueColumnValues',\n        type: 'GetColumnValuesFunction',\n        handler(column: AdaptableColumn) {\n          return mockServer.getUniqueColumnValues(column);\n        },\n      },\n    ],\n  };\n  adaptableApi = await Adaptable.init(adaptableOptions);\n\n  adaptableApi.eventApi.on('AdaptableReady', (info: AdaptableReadyInfo) => {\n    info.vendorGrid.api.setServerSideDatasource(mockServer);\n  });\n  return { adaptableOptions, adaptableApi };\n};\n\nconst BATCH_COUNT = 100;\nconst mockServer = new MockServer();\n"});case 11:case"end":return e.stop()}}),e)})));n.default=function(e){return Object(a.useEffect)((function(){F().then((function(n){e.onReady&&e.onReady(n)}))}),[]),null}}}]);